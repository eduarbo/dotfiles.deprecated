#!/usr/bin/env bash

SUPPORTED_PACKAGE_MANAGERS="brew dnf apt pacman"

### HELPERS

blue="\033[34m"
magenta="\033[35m"
green="\033[32m"
orange="\033[33m"
grey="\033[36m"
red="\033[31m"
nc="\033[0m"
bold=$(tput bold)
normal=$(tput sgr0)

_run() {
  local cmd="${@//$DOTFILES\//}"
  cmd="${cmd//$HOME/~}"
  local clr=""
  case $cmd in
    *~/.bin/) clr="${magenta}" ;;
    ln*)      clr=""           ;;
    stow*)    clr=""           ;;
    rm*)      clr="${red}" ;;
    *)        clr="${orange}"
  esac
  echo -e "  $PREFIX$clr$cmd$nc"
  [[ $DRYRUN ]] || { $@ 2>&1 | sed 's/^/  => /'; }
}

_areuthere() {
  command -v "$1" >/dev/null;
}


### PREAMBLE

shopt -s nullglob

# determine if sudo necessary
if [[ $(id -u) -gt 0 ]]; then
  SUDO='sudo'
else
  SUDO=''
fi

dep_prefix="${red}INSTALL DEPENDENCY:${nc} "

# ensure homebrew, stow and GNU's readlink are available
case "$OSTYPE" in
  darwin*)
    _areuthere brew || PREFIX=$dep_prefix _run /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    _areuthere stow || PREFIX=$dep_prefix _run brew install stow
    _areuthere greadlink || PREFIX=$dep_prefix _run brew install coreutils
    utilspath="$(dirname "$(dirname "$(greadlink -f "$0")")")/.utils.sh"
    ;;
  linux*)
    if ! _areuthere stow; then
      if _areuthere apt; then
        PREFIX=$dep_prefix _run $SUDO apt install stow
      elif _areuthere dnf; then
        PREFIX=$dep_prefix _run $SUDO dnf install stow
      fi
    fi

    utilspath="$(dirname "$(dirname "$(readlink -f "$0")")")/.utils.sh"
    ;;
esac

source "$utilspath"

[[ -L "$HOME"/.stow-global-ignore ]] || ln -s "$DOTFILES"/.stow-global-ignore "$HOME"/.stow-global-ignore

progname=$(basename "$0")


### COMMANDS

sub_help() {
  cat <<EOL
${bold}USAGE${normal}
    $progname <command> [options]

${bold}COMMANDS${normal}
    ${bold}install, i${normal}
        Symlink and run install script for given modules

    ${bold}update, u${normal}
        Run update script and prune symlinks for all installed or specified modules

    ${bold}uninstall, remove, rm${normal}
        Remove symlinks for specified modules
                
    ${bold}list, ls${normal}
        List installed modules

    To see the usage of each command use the option ${bold}-h${normal}

${bold}EXAMPLES${normal}
    Install emacs and vim modules

            $progname install emacs vim

    Don't run install script, just symlink the zsh module

            $progname install -i zsh

    Update installed modules

            $progname update

    Remove vim symlinks

            $progname rm vim
EOL
}


sub_list() {
  _help() {
    cat <<EOL
Usage: $progname $command [-a]

    -a  List all available modules
EOL
    exit
  }

  all=
  while getopts ah opt; do
    case $opt in
      a) all=1 ;;
      h) _help
         exit ;;
      *) >&2 echo "Aborted."
         exit 1 ;;
    esac
  done
  shift $((OPTIND-1))

  if [[ $all ]]; then
    pushd "$DOTFILES" >/dev/null
    ls -d */ | sed 's#/##'
    popd >/dev/null
  else
    ls -1 "$ENABLED_DIR"
  fi
}
# command alias:
sub_ls() {
  sub_list "$@"
}


sub_uninstall() {
  _help() {
    cat <<EOL
Usage: $progname $command [-da] [module1] [module2] [...]

    -d  Do a dry run (only output commands, no changes)
    -a  Remove all installed modules
EOL
    exit
  }

  # output help when arguments are missing
  [[ $# -eq 0 ]] && _help

  all=
  while getopts dah opt; do
    case $opt in
      d) DRYRUN=1 ;;
      a) all=1    ;;
      h) _help
         exit ;;
      *) >&2 echo "Aborted."
         exit 1 ;;
    esac
  done
  shift $((OPTIND-1))

  modules=$@
  [[ $all ]] && modules=$(ls -1 "$ENABLED_DIR")

  pushd "$DOTFILES" >/dev/null
  for module in $modules; do
    linkpath="${ENABLED_DIR}/${module}"
    # Skip if module is not enabled
    [[ -L $linkpath ]] || continue

    echo -e "${green}» ${module}${nc}"

    PREFIX="${red}UNSTOW:${nc} " _run stow -D -t "$HOME" "$module" # Unstow
    _run rm "$linkpath" # Deregister
  done
  popd >/dev/null
}
# command alias:
sub_remove() {
  sub_uninstall "$@"
}
sub_rm() {
  sub_uninstall "$@"
}


sub_update() {
  _help() {
    cat <<EOL
Usage: $progname $command [-dlu] [module1] [module2] [...]

    -d  Do a dry run (only output commands, no changes)
    -l  Don't update symlinks
    -u  Don't run update scripts
EOL
    exit
  }

  update=1
  link=1
  while getopts dluh opt; do
    case $opt in
      d) DRYRUN=1 ;;
      l) link=    ;;
      u) update=  ;;
      h) _help
         exit ;;
      *) >&2 echo "Aborted."
         exit 1 ;;
    esac
  done
  shift $((OPTIND-1))

  modules=${@:-$(ls -1 "$ENABLED_DIR")}

  pushd "$DOTFILES" >/dev/null
  for module in $modules; do
    linkpath="${ENABLED_DIR}/${module}"
    # Continue for loop if module is not registered as enabled
    [[ -L $linkpath ]] || continue

    echo -e "${green}» ${module}${nc}"

    updatepath="${DOTFILES}/${module}/update"
    [[ $link ]] && _run stow -R -t "$HOME" "$module" # Restow

    # run update script in a subshell, inherits everything from the current
    # script but do not transmit any change back
    [[ $update && -x $updatepath ]] && (eval "_run source $updatepath")
  done
  popd >/dev/null
}
# command alias:
sub_u() {
  sub_update "$@"
}


sub_install() {
  _help() {
    cat <<EOL
Usage: $progname $command [-dilyaS] [module1] [module2] [...]

    -d  Do a dry run (only output commands, no changes)
    -i  Don't run install scripts
    -l  Don't symlink dotfiles
    -y  Overwrite conflicts (no prompts)
    -a  Install all modules
    -S  Server mode; only install the bare minimum
EOL
    exit
  }

  # output help when arguments are missing
  [[ $# -eq 0 ]] && _help

  ##
  link=1
  install=1
  all=
  yes=
  while getopts dilyaSh opt; do
    case $opt in
      d) DRYRUN=1 ;;
      i) install= ;;
      l) link=    ;;
      y) yes=1    ;;
      a) all=1    ;;
      S) SERVER=1 ;;
      h) _help    ;;
      *) >&2 echo "Aborted."
         exit 1   ;;
    esac
  done
  shift $((OPTIND-1))

  [[ $DRYRUN ]] && echo -e "${orange}DRY RUN MODE:${nc} only output commands, no changes"

  # passed modules
  modules=$@
  [[ $all ]] && modules=$(ls -1 "$DOTFILES")

  pushd "$DOTFILES" >/dev/null
  for module in $modules; do
    [[ -d $module ]] || continue
    register=1

    echo -e "${green}» ${module}${nc}"

    if [[ $link ]]; then
      if stow -n -t "$HOME" "$module" 2>/dev/null; then
        _run stow -R -t "$HOME" "$module"
      else
        conflicts=$(stow -n -t "$HOME" "$module" 2>&1 |
                      awk '/\* existing target is neither/ {print "~/" $NF};\
                        /\* existing target is stowed/ {print "~/" $(NF-2)}')

        if [[ $yes ]]; then
          choice=y
        else
          echo -e "  ${red}CONFLICTS:${nc} $(echo "$conflicts" | tr '\n' ' ')"
          read -n 1 -rp "  Overwrite? [y/n] " choice
          echo
        fi
        case $choice in
          y|Y) for filename in $conflicts; do
                 # Remove conflictive files
                 [[ -f $HOME/$filename || -L $HOME/$filename ]] && _run rm -f "$HOME/$filename"
               done
               _run stow -t "$HOME" "$module"
               ;;
          *)   PREFIX="${red}ABORTED:${nc} " DRYRUN=1 _run stow -t "$HOME" "$module"
               register=
               ;;
        esac
      fi
    fi

    linkpath="${ENABLED_DIR}/${module}"
    modulepath="$DOTFILES/$module"

    # Register module as 'enabled'
    [[ $link && $register && ! -L $linkpath ]] && _run ln -svf "$modulepath" "$linkpath"

    # run install script in a subshell, inherits everything from the current
    # script but do not transmit any change back
    [[ $install && -x ${modulepath}/install ]] && (eval "_run source $modulepath/install")
  done
  popd >/dev/null
}
# command alias:
sub_i() {
  sub_install "$@"
}


### MAIN

command=$1
case $command in
  "" | "-h" | "--help")
    sub_help ;;
  *)
    shift
    "sub_${command}" "$@"

    if [[ $? = 127 ]]; then
      echo "Error: '$command' is not a known command." >&2
      echo "       Run '$progname --help' for a list of known commands." >&2
      exit 1
    fi
    ;;
esac
# vim:set ft=sh:
