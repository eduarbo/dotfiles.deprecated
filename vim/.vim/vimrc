" .vimrc
" Author: Eduardo Ruiz <eduarbo@gmail.com>
" Source: https://github.com/eduarbo/dotfiles/tree/master/vim

" Symbols
let s:error_sign = ''
let s:warning_sign = ''
let s:message_sign = ''
let s:info_sign = ''
let s:diff_added_sign = ' '
let s:diff_modified_sign = ' '
let s:diff_removed_sign = ' '
let s:diff_removed_first_line_sign = ' '
let s:diff_modified_removed_sign = ' '
"}}}1

" Preamble                                                                  {{{1
filetype off

let g:mapleader = ' '
let g:maplocalleader = ','

let s:ag = executable('ag')
"}}}1

" Plugins                                                                   {{{1
" Automatic installation
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

" File Finders                                                              {{{2
" Wrappers for most used UNIX commands
Plug 'tpope/vim-eunuch'

Plug 'justinmk/vim-dirvish', {
      \ 'on': ['Dirvish']
      \ }                                                                 " {{{3
nnoremap <Leader>n :Dirvish<CR>
nnoremap <Leader>N :Dirvish %<CR>
augroup ps_dirvish "{{{
  au!
  au FileType dirvish nnoremap <buffer> v
        \ :vsp <C-R>=fnameescape(getline('.'))<CR><CR>
  au FileType dirvish nnoremap <buffer> s
        \ :sp <C-R>=fnameescape(getline('.'))<CR><CR>

  " Map t to "open in new tab".
  au FileType dirvish
        \  nnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
        \ |xnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>

  " Enable :Gstatus and friends.
  au FileType dirvish call fugitive#detect(@%)

  " Map `gh` to hide dot-prefixed files.
  " To "toggle" this, just press `R` to reload.
  au FileType dirvish nnoremap <buffer>
        \ gh :keeppatterns g@\v/\.[^\/]+/?$@d<cr>

  " Map CTRL-R to reload the Dirvish buffer.
  au FileType dirvish nnoremap <buffer> <C-R> :<C-U>Dirvish %<CR>
augroup END "}}}
" }}}

Plug 'dyng/ctrlsf.vim', { 'on': [
      \ '<Plug>CtrlSFVwordPath',
      \ '<Plug>CtrlSFCwordPath',
      \ 'CtrlSFToggle',
      \ 'CtrlSF'
      \ ]}                                                                " {{{3
vmap <leader>a <Plug>CtrlSFVwordPath
nmap <leader>a <Plug>CtrlSFCwordPath
nmap <leader>A :CtrlSFToggle<CR>
vmap <leader>A :CtrlSFToggle<CR>
noremap <localleader>a :CtrlSF

let g:ctrlsf_mapping = {
      \ 'quit': '',
      \ }

" For some strage reason, CtrlSF maps q to a call. Don't fuck with macros CtrlSF!
noremap q q

let g:ctrlsf_ackprg = 'ag'
"}}}3

" Most Recently Used files
Plug 'Shougo/neomru.vim'
Plug 'junegunn/fzf.vim', {'on': ['FZF', 'FZFMru', 'FZFBuffers']}          " {{{3
" Open files in horizontal split
set runtimepath+=/usr/local/opt/fzf
" open fzf from MacVim in a new iTerm2 window
let g:fzf_launcher = '~/.vim/in_a_new_term_function %s'

let g:fzf_layout = { 'down': '~30%' }
let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-s': 'split',
      \ 'ctrl-v': 'vsplit' }

function! s:buflist() "{{{
  redir => l:ls
  silent ls
  redir END
  return split(l:ls, '\n')
endfunction "}}}

function! s:bufopen(e) "{{{
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction "}}}

command! Buffers call fzf#run(fzf#wrap('buffers', {
      \   'source':  reverse(<sid>buflist()),
      \   'sink':    function('<sid>bufopen'),
      \   'options': '+m',
      \   'down':    len(<sid>buflist()) + 2
      \ }))

command! Mru call fzf#run(fzf#wrap('mru', {
      \   'source':  'sed "1d" $HOME/.cache/neomru/file'
      \ }))

nnoremap <silent> <leader>, :FZF<CR>
nnoremap <silent> <leader>m :Mru<CR>
nnoremap <silent> <Leader>b :Buffers<CR>
"}}}3
"}}}2

" General Code                                                              {{{2
" vim-snippets depends on ultisnips
Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'                       " {{{3

" remap Ultisnips for compatibility for YCM
let g:UltiSnipsExpandTrigger = '<C-j>'
let g:UltiSnipsJumpForwardTrigger = '<C-j>'
let g:UltiSnipsJumpBackwardTrigger = '<C-k>'

let g:UltiSnipsSnippetDirectories=['UltiSnips', 'ultisnippets']
" }}}
"
Plug 'ervandew/supertab'

" Plug 'Valloric/YouCompleteMe', {'do': './install.py --clang-completer'} " {{{3

" let g:ycm_auto_trigger = 1
" let g:ycm_min_num_of_chars_for_completion = 2
" let g:ycm_use_ultisnips_completer = 1
" let g:ycm_autoclose_preview_window_after_completion = 1
" let g:ycm_always_populate_location_list = 0
" let g:ycm_enable_diagnostic_signs = 0
" let g:ycm_enable_diagnostic_highlighting = 0
" let g:ycm_echo_current_diagnostic = 0
" let g:ycm_open_loclist_on_ycm_diags = 0
" let g:ycm_seed_identifiers_with_syntax = 0
" let g:ycm_key_list_select_completion = ['<C-n>']
" let g:ycm_key_list_previous_completion = ['<C-p>']
" let g:ycm_key_invoke_completion = '<C-n>'
" let g:ycm_collect_identifiers_from_tags_files = 0

" augroup ycm "{{{
"   au!
"   au FileType python* setlocal omnifunc=pythoncomplete#Complete
"   au FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
"   au FileType html*,markdown setlocal omnifunc=htmlcomplete#CompleteTags
"   au Filetype css*,scss,less setlocal omnifunc=csscomplete#CompleteCSS
"   au FileType ruby setlocal omnifunc=rubycomplete#Complete
"   au FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"   au FileType haskell setlocal omnifunc=necoghc#omnifunc
" augroup END "}}}
" "                                                                          }}}

Plug 'kien/rainbow_parentheses.vim', {'for': 'clojure'}                   " {{{3
augroup rainbow_parentheses "{{{
  au!
  au FileType clojure RainbowParenthesesActivate
  au syntax clojure RainbowParenthesesLoadRound
  au syntax clojure RainbowParenthesesLoadSquare
  au syntax clojure RainbowParenthesesLoadBraces
augroup END "}}}
" }}}

Plug 'tpope/vim-commentary'                                               " {{{3
nmap <leader>c <Plug>CommentaryLine
xmap <leader>c <Plug>Commentary

augroup plugin_commentary "{{{
  au!
  au FileType clojurescript setlocal commentstring=;\ %s
  au FileType puppet,tmux setlocal commentstring=#\ %s
augroup END "}}}
" }}}3

Plug 'benekastah/neomake'                                                 " {{{3
let g:neomake_javascript_enabled_makers = ['eslint']
let g:neomake_json_enabled_makers = ['jsonlint']
let g:neomake_ruby_enabled_makers = ['mri']
let g:neomake_python_enabled_makers = ['flake8']
let g:neomake_c_enabled_makers = ['gcc', 'clang-tidy']
let g:neomake_cpp_enabled_makers = ['g++', 'clang-tidy']
let g:neomake_airline = 1

let g:neomake_error_sign = {
      \ 'text': s:error_sign,
      \ 'texthl': 'GruvboxRedSign'
      \ }

let g:neomake_warning_sign = {
      \ 'text': s:warning_sign,
      \ 'texthl': 'GruvboxYellowSign'
      \ }

let g:neomake_message_sign = {
      \ 'text': s:message_sign,
      \ 'texthl': 'GruvboxGreenSign'
      \ }

let g:neomake_info_sign = {
      \ 'text': s:info_sign,
      \ 'texthl': 'GruvboxBlueSign'
      \ }

autocmd! BufWritePost,BufEnter * Neomake
" }}}

Plug 'bkad/CamelCaseMotion'                                               " {{{3
map <S-W> <Plug>CamelCaseMotion_w
map <S-B> <Plug>CamelCaseMotion_b
map <S-E> <Plug>CamelCaseMotion_e

" Replace default 'iw' text-object and define 'ib' and 'ie' motions:
omap <silent> iW <Plug>CamelCaseMotion_iw
xmap <silent> iW <Plug>CamelCaseMotion_iw
omap <silent> iB <Plug>CamelCaseMotion_ib
xmap <silent> iB <Plug>CamelCaseMotion_ib
omap <silent> iE <Plug>CamelCaseMotion_ie
xmap <silent> iE <Plug>CamelCaseMotion_ie
" }}}

Plug 'terryma/vim-expand-region'
Plug 'rstacruz/vim-closer'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-endwise'
Plug 'kshenoy/vim-origami'                                                " {{{
let g:OrigamiFoldAtCol = '-3'
"}}}
Plug 'Konfekt/FastFold'                                                   " {{{
let g:fastfold_skip_filetypes= [ 'taglist' ]
"}}}
Plug 'kopischke/vim-stay'                                                 " {{{
set viewoptions=cursor,folds,slash,unix
"}}}
"}}}2

" Productivity                                                              {{{2

Plug 'mhinz/vim-sayonara', { 'on': 'Sayonara' } "{{{
nnoremap <leader>q :Sayonara<cr>
nnoremap <leader>Q :Sayonara!<cr>
"}}}

Plug 'easymotion/vim-easymotion' "{{{
let g:EasyMotion_do_mapping = 0 " Disable default mappings
let g:EasyMotion_smartcase = 1  " Turn on case insensitive feature

" s{char}{char} to move to {char}{char}
nmap s <Plug>(easymotion-s2)
xmap s <Plug>(easymotion-s2)
omap s <Plug>(easymotion-s2)
nmap t <Plug>(easymotion-t2)

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)
"}}}

Plug 'AndrewRadev/linediff.vim', {'on': ['Linediff', 'LinediffReset']}    " {{{3
vnoremap <leader>d :Linediff<cr>
nnoremap <leader>D :LinediffReset<cr>
" }}}

Plug 'mbbill/undotree', {'on': 'UndotreeToggle'}                          " {{{3
nnoremap <F4> :UndotreeToggle<cr>
" If undotree is opened, it is likely one wants to interact with it.
let g:undotree_SetFocusWhenToggle=1
let g:undotree_WindowLayout = 2
"}}}

" This makes the autoread option work properly for terminal
Plug 'tmux-plugins/vim-tmux-focus-events'

Plug 'benmills/vimux'                                                     " {{{3
" Prompt for a command to run
map <LocalLeader>vp :VimuxPromptCommand<CR>
" Run last command executed by VimuxRunCommand
map <LocalLeader>vl :VimuxRunLastCommand<CR>
" Inspect runner pane
map <LocalLeader>vi :VimuxInspectRunner<CR>
" Close vim tmux runner opened by VimuxRunCommand
map <LocalLeader>vq :VimuxCloseRunner<CR>
" Interrupt any command running in the runner pane
map <LocalLeader>vx :VimuxInterruptRunner<CR>
" Zoom the runner pane (use <bind-key> z to restore runner pane)
map <LocalLeader>vz :call VimuxZoomRunner()<CR>"

augroup vimux "{{{
  au!
  au VimLeave * :VimuxCloseRunner  " Close Vimux pane on Leav

  au FileType sh nnoremap <buffer> <localleader>e :VimuxRunCommand 'sh '.bufname('%')<CR>

  au FileType python* nnoremap <buffer> <localleader>ve :VimuxRunCommand 'clear; ipython '.bufname('%')<CR>
  au FileType python* nnoremap <buffer> <localleader>vr :VimuxRunCommand 'clear; ipython'<CR>

  au FileType ruby nnoremap <buffer> <localleader>ve :VimuxRunCommand 'clear; ruby '.bufname('%')<CR>
  au FileType ruby nnoremap <buffer> <localleader>vr :VimuxRunCommand 'clear; irb'<CR>

  au FileType go nnoremap <buffer> <localleader>ve :VimuxRunCommand 'clear; go run '.bufname('%')<CR>
  au FileType go nnoremap <buffer> <localleader>vr :VimuxRunCommand 'clear; gore'<CR>

  au FileType javascript nnoremap <buffer> <localleader>ve :VimuxRunCommand 'clear; node '.bufname('%')<CR>
  au FileType javascript nnoremap <buffer> <localleader>vr :VimuxRunCommand 'clear; node'<CR>
augroup END "}}}

function! VimuxSlime() "{{{
  " Send selected text to Tmux
  call VimuxSendText(@v)
  call VimuxSendKeys('Enter')
endfunction "}}}

" If text is selected, save it in the v buffer and send that buffer it to tmux
vnoremap <silent> <Plug>SendSelectedLineToTmux "vy :<C-u>call VimuxSlime()<CR>j
      \:call repeat#set("\<Plug>SendSelectedLineToTmux")<CR>
" TODO: Is not sending the indentation properly. FIXIT!
"
vmap <LocalLeader>vs <Plug>SendSelectedLineToTmux

" Select current line and send it to tmux
nnoremap <silent> <Plug>SendCurrentLineToTmux mz^vg_"vy :<C-u>call VimuxSlime()<CR>`zj
      \:call repeat#set("\<Plug>SendCurrentLineToTmux")<CR>
nmap <LocalLeader>vs <Plug>SendCurrentLineToTmux
" }}}

Plug 'tpope/vim-fugitive'                                                 " {{{3
nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>ga :Gadd<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>go :Gcheckout<cr>
nnoremap <leader>gc :Gcommit<cr>
nnoremap <leader>gm :Gmove<cr>
nnoremap <leader>gr :Gremove<cr>
nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>

" Hub
nnoremap <leader>gh :Gbrowse<cr>
vnoremap <leader>gh :Gbrowse<cr>

augroup ft_fugitive "{{{
  au!
  au BufNewFile,BufRead .git/index setlocal nolist
augroup END "}}}
" }}}

Plug 'airblade/vim-gitgutter'                                             " {{{3
let g:gitgutter_map_keys = 1
let g:gitgutter_sign_added = s:diff_added_sign
let g:gitgutter_sign_modified = s:diff_modified_sign
let g:gitgutter_sign_removed = s:diff_removed_sign
let g:gitgutter_sign_removed_first_line = s:diff_removed_first_line_sign
let g:gitgutter_sign_modified_removed = s:diff_modified_removed_sign

Plug 'christoomey/vim-tmux-navigator'
Plug 'vim-scripts/listmaps.vim', {'on': 'Listmaps'}
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-repeat'
Plug 'ConradIrwin/vim-bracketed-paste'
Plug 'kshenoy/vim-signature'
Plug 'wellle/targets.vim'

Plug 'mtth/scratch.vim', {'on': [
      \'Scratch', 'ScratchInsert', 'ScratchPreview', 'ScratchSelection',
      \'<Plug>(scratch-insert-reuse)', '<Plug>(scratch-insert-clear)',
      \'<Plug>(scratch-selection-reuse)', '<Plug>(scratch-selection-clear)'
      \ ]}                                                                " {{{3
let g:scratch_horizontal = 0
let g:scratch_top = 0
let g:scratch_height = 80
let g:scratch_no_mappings = 1
let g:scratch_insert_autohide = 0

nmap <localleader>s <Plug>(scratch-insert-reuse)
nmap <localleader>S <Plug>(scratch-insert-clear)
xmap <localleader>s <Plug>(scratch-selection-reuse)
xmap <localleader>S <Plug>(scratch-selection-clear)
" }}}
"}}}2

" Language-specific                                                         {{{2
Plug 'fatih/vim-go', {'for': 'go'}                                        " {{{3
let g:go_doc_keywordprg_enabled = 0

let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1

" prevent "vim-go" from showing a quickfix window when |g:go_fmt_command| fails
let g:go_fmt_fail_silently = 1
" }}}
Plug 'tpope/vim-git'
Plug 'lambdatoast/elm.vim'

" Markdown
Plug 'shime/vim-livedown', {'for': ['markdown']}
Plug 'plasticboy/vim-markdown', {'for': ['markdown']}

" Python
Plug 'hynek/vim-python-pep8-indent'
Plug 'davidhalter/jedi-vim'                                               " {{{3
let g:jedi#auto_initialization = 1
" this prevents jedi to mess with completeopt
let g:jedi#auto_vim_configuration = 0
let g:jedi#completions_enabled = 0
let g:jedi#smart_auto_mappings = 1
let g:jedi#show_call_signatures = 1

let g:jedi#goto_command = "<C-]>"
let g:jedi#documentation_command = '<localleader>m'
let g:jedi#goto_assignments_command = ""
let g:jedi#goto_definitions_command = ""
let g:jedi#usages_command = ""
let g:jedi#rename_command = ""
" }}}

" Css, Scss, Less
Plug 'hail2u/vim-css3-syntax'
Plug 'groenewege/vim-less'
Plug 'rstacruz/vim-hyperstyle'

" Html and templating languages
Plug 'othree/html5.vim'                                                   " {{{3
let g:event_handler_attributes_complete = 0
let g:rdfa_attributes_complete = 0
let g:microdata_attributes_complete = 0
let g:atia_attributes_complete = 0
" }}}
Plug 'mustache/vim-mustache-handlebars'
Plug 'tpope/vim-haml'

" Javascript
Plug 'maksimr/vim-jsbeautify', {'do': 'npm install -g js-beautify'}       " {{{3
augroup ft_jsbeautify "{{{
  au!
  autocmd FileType javascript nnoremap <buffer>  <localleader>= :call JsBeautify()<cr>
  autocmd FileType javascript vnoremap <buffer>  <localleader>= :call RangeJsBeautify()<cr>
  " for html
  autocmd FileType html* nnoremap <buffer> <localleader>= :call HtmlBeautify()<cr>
  autocmd FileType html* vnoremap <buffer> <localleader>= :call RangeHtmlBeautify()<cr>
  " for css or scss
  autocmd FileType css* nnoremap <buffer> <localleader>= :call CSSBeautify()<cr>
  autocmd FileType css* vnoremap <buffer> <localleader>= :call RangeCSSBeautify()<cr>
augroup END "}}}
" }}}
Plug 'elzr/vim-json'                                                      " {{{3
let g:vim_json_syntax_conceal = 0
" }}}
Plug 'jason0x43/vim-js-indent'                                            " {{{3
let g:js_indent_flat_switch = 1
" }}}
Plug 'heavenshell/vim-jsdoc'
" supports latest language features
Plug 'othree/es.next.syntax.vim', { 'for': 'javascript' }
Plug 'othree/yajs.vim'
Plug 'othree/javascript-libraries-syntax.vim'

" Ruby
Plug 'vim-ruby/vim-ruby'
Plug 'tpope/vim-rails'
"}}}2

" Style                                                                     {{{2
Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes' "{{{
let g:airline_powerline_fonts = 1
let g:airline_theme='tomorrow'
let g:airline_section_z = '%3P '
" let g:airline_skip_empty_sections = 1
let g:airline#extensions#tagbar#enabled = 0
let g:airline#extensions#wordcount#enabled = 0

let g:airline#extensions#neomake#error_symbol = s:error_sign.' '
let g:airline#extensions#neomake#warning_symbol = s:warning_sign.' '
let g:airline#extensions#whitespace#symbol = 'Ξ'
let g:airline#extensions#whitespace#trailing_format = '%s'
let g:airline_left_sep=''
let g:airline_right_sep=''
let g:airline#extensions#hunks#hunk_symbols = [
      \ s:diff_added_sign,
      \ s:diff_modified_sign,
      \ s:diff_removed_sign ]
let g:airline#extensions#default#layout = [
      \ [ 'a', 'b', 'c' ],
      \ [ 'x', 'z', 'error', "warning" ] 
      \ ]
let g:airline_symbols = {
      \ 'branch': '',
      \ 'paste': '',
      \ 'spell': ''
      \ }

let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : '',
      \ 'i'  : '',
      \ 'R'  : '',
      \ 'c'  : '',
      \ 'v'  : '',
      \ 'V'  : '',
      \ '' : '',
      \ 's'  : '',
      \ 'S'  : '',
      \ '' : '',
      \ 't'  : '',
      \ }
"}}}
Plug 'morhetz/gruvbox' "{{{
" Guvbox specific
let g:gruvbox_italic=1
let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_invert_selection = 0
let g:gruvbox_sign_column = 'bg0'
let g:gruvbox_number_column = 'dark0_soft'

" Override gruvbox colors
augroup custom_gruvbox
  au!

  autocmd ColorScheme gruvbox
        \ call fn#HL('VertSplit', ['#32302f', 236]) |
        \ call fn#HL('jsonCommentError', ['#fabd2f', 167]) |
        \ call fn#HL('FoldColumn', ['#504945', 239]) |
        \ call fn#HL('Folded', ['#504945', 239], ['#282828', 235]) |
        \ call fn#HL('Comment', ['#504945', 239], ['NONE', 'NONE'], 'italic,') |
        \ call fn#HL('CursorLine', ['NONE', 'NONE'], ['#282828', 235]) |
        \ call fn#HL('CursorColumn', ['NONE', 'NONE'], ['#282828', 235]) |
        \ call fn#HL('CursorLineNr', ['#fabd2f', 214]) |
        \ call fn#HL('ColorColumn',  ['NONE', 'NONE'], ['#282828', 235])
augroup END
"}}}
"}}}2

call plug#end()
"}}}1

" FileTypes                                                                 {{{1
augroup ft_common "{{{
  au!
  au BufNewFile,BufRead *.hamlc set filetype=haml
  au BufNewFile,BufRead *jshintrc set filetype=json
augroup END "}}}

augroup ft_c "{{{
  au!

  au FileType c setlocal foldmethod=marker
  au FileType c setlocal foldmarker={,}
augroup END "}}}

augroup ft_css "{{{
  au!

  au FileType css,scss,less setlocal foldmethod=marker
  au FileType css,scss,less setlocal foldmarker={,}
  au FileType css,scss,less setlocal iskeyword+=-
augroup END "}}}

augroup ft_clojure "{{{
  au!

  au BufNewFile,BufRead riemann.config set filetype=clojure
augroup END "}}}

augroup ft_clojurescript "{{{
  au!

  au BufNewFile,BufRead *.cljs set filetype=clojurescript
augroup END "}}}

augroup ft_help "{{{
  au!

  au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif

  au FileType help setlocal textwidth=78
augroup END "}}}

augroup ft_html_and_templates "{{{
  au!

  au BufNewFile,BufRead *.html set syntax=mustache
  au BufNewFile,BufRead *.hbs,*.handlebars set ft=mustache syntax=mustache

  au FileType html*,mustache setlocal foldlevel=99
  au FileType html*,mustache setlocal foldmethod=manual
  au FileType html*,mustache setlocal shiftwidth=4
  au FileType html*,mustache setlocal softtabstop=4
  au FileType html*,mustache setlocal tabstop=4

  au FileType mustache setlocal commentstring={{!\ %s\ }}
  au FileType handlebars setlocal commentstring={{!\ %s\ }}
  au FileType htmldjango setlocal commentstring={#\ %s\ #}

  " Use <localleader>f to fold the current tag.
  au FileType html*,mustache nnoremap <buffer> <localleader>f Vatzf

  " Indent tag
  au FileType html*,mustache nnoremap <buffer> <localleader>- Vat=

  " handlebars tags
  au FileType html*,mustache inoremap <buffer> <c-b> {{<space><space>}}<left><left><left>

  " HTML tag closing
  au FileType html*,mustache inoremap <buffer> <C-_> <space><bs><esc>:call InsertCloseTag()<cr>a
augroup END "}}}

augroup ft_java "{{{
  au!

  au FileType java setlocal foldmethod=marker
  au FileType java setlocal foldmarker={,}
  au FileType java setlocal makeprg=javac\ %
  au FileType java setlocal errorformat=%A%f:%l:\ %m,%-Z%p^,%-C%.%#
augroup END "}}}

augroup ft_json "{{{
  au FileType json noremap <buffer> <localleader>= :<c-u>%!python -m json.tool<cr>
augroup END "}}}

augroup ft_javascript "{{{
  au!

  au BufNewFile,BufRead *.es6 set filetype=javascript

  au FileType javascript setlocal foldmethod=marker
  au FileType javascript setlocal foldmarker={,}
  au FileType javascript setlocal foldtext=getline(v:foldstart)
  au FileType javascript setlocal shiftwidth=2 softtabstop=2 tabstop=2
  au FileType javascript setlocal foldlevel=99
  au FileType javascript call MakeSpacelessBufferIabbrev('clog', 'console.log();<left><left>')
augroup END "}}}

augroup ft_man "{{{
  au!

  au FileType man nnoremap <buffer> <cr> :q<cr>
augroup END "}}}

augroup ft_markdown "{{{
  au!

  au BufNewFile,BufRead *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=markdown

  au FileType markdown normal! zR
  au FileType markdown setlocal foldlevel=1
  au FileType markdown setlocal nofoldenable    " disable folding

  " Use <localleader>1/2/3 to add headings.
  au FileType markdown nnoremap <buffer> <localleader>1 yypVr=:redraw<cr>
  au FileType markdown nnoremap <buffer> <localleader>2 yypVr-:redraw<cr>
  au FileType markdown nnoremap <buffer> <localleader>3 mzI###<space><ESC>`zllll
augroup END "}}}

augroup ft_nginx "{{{
  au!

  au BufNewFile,BufRead /etc/nginx/conf/*                      setlocal ft=nginx
  au BufNewFile,BufRead /etc/nginx/sites-available/*           setlocal ft=nginx
  au BufNewFile,BufRead /usr/local/etc/nginx/sites-available/* setlocal ft=nginx
  au BufNewFile,BufRead vhost.nginx                            setlocal ft=nginx

  au FileType nginx setlocal foldmethod=marker
  au FileType nginx setlocal foldmarker={,}
augroup END "}}}

augroup ft_python "{{{
  au!

  au BufNewFile,BufRead admin.py,urls.py,models.py,views.py,settings.py,forms.py,
        \common_settings.py set filetype=python.django
  au BufNewFile,BufRead settings.py,common_settings.py setlocal foldmethod=marker

  au FileType python* setlocal define=^\s*\\(def\\\\|class\\)
  au FileType python* setlocal shiftwidth=4 softtabstop=4 tabstop=4

  " Jesus, Python.  Five characters of punctuation for a damn string?
  au FileType python* inoremap <buffer> <c-g> _(u'')<left><left>
  au FileType python* inoremap <buffer> <c-b> """"""<left><left><left>

  " Jesus tapdancing Christ, built-in Python syntax, you couldn't let me
  " override this in a normal way, could you?
  au FileType python* if exists("python_space_error_highlight") | unlet python_space_error_highlight | endif
augroup END "}}}

augroup ft_qf "{{{
  au!

  au FileType qf setlocal colorcolumn=0
  au FileType qf setlocal nolist
  au FileType qf setlocal nocursorline
  au FileType qf setlocal nowrap
  au FileType qf setlocal textwidth=0
augroup END "}}}

augroup ft_ruby "{{{
  au!

  au BufNewFile,BufRead Vagrantfile,Capfile set filetype=ruby
  au FileType ruby setlocal foldmethod=syntax
  au FileType ruby nnoremap <buffer> <localleader>b :call <SID>toggleStatement("require 'pry'; binding.pry  # XXX BREAKPOINT")<CR>
augroup END "}}}

augroup ft_sql "{{{
  au!

  au BufNewFile,BufRead *.sql.pre,*.sql.post set filetype=sql
  au FileType sql setlocal foldmethod=indent
augroup END "}}}

augroup ft_vim "{{{
  au!

  " Reload vimrc
  " au BufWritePost vimrc so %

  au FileType vim setlocal foldmethod=marker
  au FileType vim setlocal keywordprg=:help
  au FileType vim setlocal shiftwidth=2
  au FileType vim setlocal softtabstop=2
  au FileType vim setlocal tabstop=2
  au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END "}}}

augroup ft_xml "{{{
  au!

  au FileType xml setlocal foldmethod=manual

  " Use <localleader>f to fold the current tag.
  au FileType xml nnoremap <buffer> <localleader>f Vatzf

  " Indent tag
  au FileType xml nnoremap <buffer> <localleader>= Vat=
augroup END "}}}

"}}}1

" Basic options                                                             {{{1
filetype plugin indent on

" Use Ag as default grep if available
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor\ --column
  set grepformat=%f:%l:%c:%m
  command! -nargs=+ -bang Ag silent! grep <args> | redraw! | botright copen
endif

" :set encoding should be described before :scriptencoding, otherwise Vim can
" not recognize the character code of your vimrc
" set encoding=utf-8
scriptencoding utf-8

set modeline
set autoindent                  " Automatically set the indent of a new line (local to buffer)
set noshowmode                  " Hide current mode down the bottom
set noshowcmd                   " Hide incomplete cmds down the bottom
set hidden
set visualbell                  " No sounds
set t_vb=                       " Visual bell disabled on Linux
set ttyfast                     " Improves redrawing
" set ttyscroll=10
set noruler                     " Never show current positions along the bottom
set backspace=indent,eol,start  " Allow backspace in insert mode
set number                      " Line numbers are good
set laststatus=2                " Never show the status line
set history=1000                " Store lots of :cmdline history
set list                        " Hide invisible chars
set listchars=tab:▸\ ,eol:↵,extends:↷,precedes:↶,trail:·
set shell=/bin/zsh\ --login
set matchtime=3                 " how many tenths of a second to blink
set showbreak=↪
set splitbelow
set splitright
set iskeyword+=-
"set fillchars=diff:⣿,vert:┃,stl:━,stlnc:━     " Customize text for closed folds
set fillchars=diff:⣿,vert:┃     " Customize text for closed folds
set autowrite
set autoread                    " Reload files changed outside vim
set shiftround                  " When at 3 spaces, and I hit > ... go to 4, not 5
set title                       " set the terminal title to the current file
set linebreak
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
set pastetoggle=<F2>            " Use it for pasting large amounts of text into Vim, disabling all kinds of smartness and just pasting a whole buffer of text
set sessionoptions-=options     " do not store global and local values in a session
set sessionoptions-=folds       " do not store folds
set display+=lastline           " Show partially hidden wrapped lines
set tabpagemax=50
set sessionoptions-=options

" Make Vim more responsive
set nocursorline
set nocursorcolumn
set scrolljump=10
set lazyredraw " Do not redraw while running macros
set synmaxcol=255 " Don't try to highlight lines longer than 255 characters

" set tags=./tags

if v:version > 702
  set norelativenumber            " It is much faster
  set undofile
  set undoreload=10000
  set colorcolumn=+1
  syntax sync minlines=256
endif

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
set notimeout
set ttimeout
set ttimeoutlen=10

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"

" Better Completion
" set complete=.,w,b,u,t
set complete=.,b,u,]
" get rid of `preview` option to prevent scratch window to pop up
set completeopt=longest,menuone

" Resize splits when the window is resized
augroup resize_splits "{{{
  au!
  au VimResized * :wincmd =
augroup END "}}}

" Wildmenu completion                                                       {{{2
set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.bak,*.?~,*.??~,*.???~,*.~      " Backup files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit
set wildignore+=*.jar                            " Java archives
set wildignore+=*.pyc                            " Python bite code
set wildignore+=*.luac                           " Lua byte code
set wildignore+=*.orig                           " Merge resolution files
"}}}2

" Line Return                                                               {{{2
" Make sure Vim returns to the same line when you reopen a file.
" Thanks, Amit
augroup line_return "{{{
  au!
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END "}}}
"}}}2

" Tabs, spaces, wrapping                                                    {{{2
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set wrap
set textwidth=80
set formatoptions=qrn1

if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j " Delete comment character when joining commented lines
endif

if !empty(&viminfo)
  set viminfo^=!
endif
"}}}2

" Backups                                                                   {{{2
set backup                        " enable backups
set noswapfile                    " It's 2012, Vim.

set undodir=$HOME/.vim/tmp/undo/     " undo files
set backupdir=$HOME/.vim/tmp/backup/ " backups
set directory=$HOME/.vim/tmp/swap/   " swap files

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
  call mkdir(expand(&undodir), 'p')
endif
if !isdirectory(expand(&backupdir))
  call mkdir(expand(&backupdir), 'p')
endif
if !isdirectory(expand(&directory))
  call mkdir(expand(&directory), 'p')
endif
"}}}2

"}}}1

" Abbreviations                                                             {{{1
function! EatChar(pat) "{{{
  let l:c = nr2char(getchar(0))
  return (l:c =~ a:pat) ? '' : l:c
endfunction "}}}

function! MakeSpacelessIabbrev(from, to) "{{{
  execute 'iabbrev <silent> '.a:from.' '.a:to."<C-R>=EatChar('\\s')<CR>"
endfunction "}}}
function! MakeSpacelessBufferIabbrev(from, to) "{{{
  execute 'iabbrev <silent> <buffer> '.a:from.' '.a:to."<C-R>=EatChar('\\s')<CR>"
endfunction "}}}

call MakeSpacelessIabbrev('gh/',  'http://github.com/')
call MakeSpacelessIabbrev('ghe/',  'http://github.com/eduarbo')
call MakeSpacelessIabbrev('me/',  'Eduardo Ruiz Macias')
call MakeSpacelessIabbrev('em/',  'eduarbo@gmail.com')

iabbrev ldis ಠ_ಠ
iabbrev lsad ಥ_ಥ
iabbrev lhap ಥ‿ಥ
iabbrev lmis ಠ‿ಠ
"}}}1

" Convenience mappings                                                      {{{1
" Terminal sends Nul when C-space is pressed
noremap <C-space> <Nul>

" Fuck you, help key.
noremap  <F1> <ESC>
inoremap <F1> <ESC>

" Stop it, hash key.
inoremap # X<BS>#

" Kill window
nnoremap K :q<cr>

" Sort lines
nnoremap <leader>S vip:!sort<cr>
vnoremap <leader>S :!sort<cr>

" Close Preview window
noremap <localleader>p <C-w>z

nnoremap ; :

" Use c-\ to do c-] but open it in a new split.
nnoremap <c-\> <c-w>v<c-]>zvzz

" Insert New Line (not compatible with terminal)
nnoremap <S-Enter> O<ESC> " awesome, inserts new line without going into insert mode
nnoremap <Enter> o<ESC>

" Go to previous file
nnoremap <leader>/ <C-^>

" Sigh.
nnoremap <leader><cr> :silent !/usr/local/bin/ctags -R . && sed -i .bak -E -e '/^[^	]+	[^	]+.py	.+v$/d' tags<cr>:redraw!<cr>

" Clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Copy/Paste to and from Desktop Environment
noremap <leader>y "+y
noremap <leader>p "+p
noremap <leader>P "+P

" Make the Y behavior similar to D & C
nnoremap Y y$

" Insert the directory of the current buffer in command line mode
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Select entire buffer
nnoremap vaa ggvGg_
nnoremap Vaa ggVG

" Panic Button
nnoremap <leader>` mzggg?G`z

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Formatting, TextMate-style
vnoremap <silent> <Plug>FormatSelection gq
      \:call repeat#set("\<Plug>FormatSelection")<CR>
nnoremap <silent> <Plug>FormatLine ^vg_gq$
      \:call repeat#set("\<Plug>FormatLine")<CR>

vmap Q <Plug>FormatSelection
nmap Q <Plug>FormatLine

" Easier linewise reselection
nnoremap <leader>V V`]

"identation
vnoremap < <gv
vnoremap > >gv

" Indent/dedent/autoindent what you just pasted.
nnoremap <lt>> V`]<
nnoremap ><lt> V`]>
nnoremap =- V`]=

" indent all
nnoremap <localleader>= mzgg=G`z

" Keep the cursor in place while joining lines
nnoremap J mzJ`z

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" Select (charwise) the contents of the current line, excluding indentation.
" Great for pasting Python lines into REPLs.
nnoremap vv ^vg_

" Sudo to write
cnoremap w!! w !sudo tee % >/dev/null

" Typos
command! -bang E e<bang>
command! -bang Q q<bang>
command! -bang W w<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang Wa wa<bang>
command! -bang WA wa<bang>
command! -bang Wq wq<bang>
command! -bang WQ wq<bang>

" I suck at typing.
nnoremap <localleader>- ==
vnoremap - =

" Toggle [i]nvisible characters
nnoremap <leader>i :set list!<cr>

" Unfuck my screen
nnoremap U :syntax sync fromstart<cr>:redraw!<cr>

" my Function Mappings                                                      {{{2

" Removes current file and wipe out the buffer
command! Rm call delete(expand('%')) | bdelete!

" Zoom / Restore window
command! ZoomToggle call fn#ZoomToggle()
nnoremap <silent> <leader>z :ZoomToggle<CR>

" Google it
vnoremap <silent> <leader>? "gy<Esc>:call fn#GoogleIt(@g)<CR>:redraw!<CR>

" Show the stack of syntax hilighting groups affecting whatever is under the
" cursor.
command! SynStack call fn#SynStack()
nnoremap <F7> :call fn#SynStack()<CR>

command! ToggleProfile call fn#ToggleProfile()
nnoremap <localleader>\ :call fn#ToggleProfile()<CR>

" Encode and Decode

" TODO: Make a command to encode and decode and remove mappings
" command! Base64encode -nargs=1 silent! system('base64', <args>)
" vnoremap <localleader>d c<c-r>=system('base64 --decode', @")<cr><esc>
" vnoremap <localleader>e c<c-r>=system('base64', @")<cr><esc>

" QuickFix and Location-list cycle mappings compatible with repeat plugin. This
" fixes Syntastic error jumping too
nnoremap <silent> <Plug>QuickfixNext     :call fn#CycleCommand('cnext', 'cfirst')<CR>
      \:silent! call repeat#set("\<Plug>QuickfixNext")<CR>
nnoremap <silent> <Plug>QuickfixPrevious :call fn#CycleCommand('cprev', 'clast')<CR>
      \:silent! call repeat#set("\<Plug>QuickfixPrevious")<CR>
nnoremap <silent> <Plug>LocationNext     :call fn#CycleCommand('lnext', 'lfirst')<CR>
      \:silent! call repeat#set("\<Plug>LocationNext")<CR>
nnoremap <silent> <Plug>LocationPrevious :call fn#CycleCommand('lprev', 'llast')<CR>
      \:silent! call repeat#set("\<Plug>LocationPrevious")<CR>

" Override unimpaired mappings
augroup syntastic_mappings "{{{
  autocmd!
  autocmd VimEnter * nmap <silent> ]q <Plug>QuickfixNext
  autocmd VimEnter * nmap <silent> [q <Plug>QuickfixPrevious
  autocmd VimEnter * nmap <silent> ]l <Plug>LocationNext
  autocmd VimEnter * nmap <silent> [l <Plug>LocationPrevious
augroup END "}}}
"}}}2
"}}}1

" Quick editing                                                             {{{1
nnoremap <leader>ec :vsplit ~/.dotfiles/linters/.editorconfig<cr>
nnoremap <leader>ej :vsplit ~/.dotfiles/lintesr/.jshintrc<cr>
nnoremap <leader>ed :vsplit ~/.vim/custom-dictionary.utf-8.add<cr>
nnoremap <leader>eg :vsplit ~/.dotfiles/git/.gitconfig<cr>
nnoremap <leader>et :vsplit ~/.dotfiles/tmux/.tmux.conf<cr>
nnoremap <leader>ez :vsplit ~/.dotfiles/zsh/.zshrc<cr>
nnoremap <leader>ev :vsplit ~/.dotfiles/vim/.vim/vimrc<cr>
nnoremap <leader>eb :vsplit ~/.dotfiles/bash/.bash_profile<cr>
"}}}1

" Searching and movement                                                    {{{1
" Use sane regexes.
nnoremap / /\v
vnoremap / /\v

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

nnoremap <tab> %
silent! unmap [%
silent! unmap ]%

" Made D behave
nnoremap D d$

" Don't move on *
nnoremap * *<c-o>

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv
noremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

" Same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" Easier to type, and I never use the default behavior.
noremap H ^
noremap L $
vnoremap L g_

" Heresy
inoremap <c-a> <esc>I
inoremap <c-e> <esc>A

" gi already moves to "last place you exited insert mode", so we'll map gI to
" something similar: move to last change
nnoremap gI `.

" Fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" Toggle "keep current line in the center of the screen" mode
nnoremap <leader>C :let &scrolloff=999-&scrolloff<cr>

" Directional Keys                                                          {{{2
" It's 2012.
noremap j gj
noremap k gk
noremap gj j
noremap gk k

noremap - <C-w>-
noremap + <C-w>+

nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

nnoremap <leader>v <C-w>v
nnoremap <leader>s <C-w>s
"}}}2
" Visual Mode */# from Scrooloose                                           {{{2
function! s:VSetSearch() "{{{
  let l:temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = l:temp
endfunction "}}}

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>
"}}}2
"}}}1

" Folding                                                                   {{{1
set foldmethod=marker
set foldenable
set foldlevel=0
set foldlevelstart=0
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
set foldtext=fn#BetterFoldText()

nnoremap <silent> zr zr:<c-u>setlocal foldlevel?<CR>
nnoremap <silent> zm zm:<c-u>setlocal foldlevel?<CR>

nnoremap <silent> zR zR:<c-u>setlocal foldlevel?<CR>
nnoremap <silent> zM zM:<c-u>setlocal foldlevel?<CR>

" Space to toggle folds.
nnoremap <localleader><localleader> za
vnoremap <localleader><localleader> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

" Change Option Folds
nnoremap zi  :<c-u>call <SID>ToggleFoldcolumn(1)<CR>
nnoremap coz :<c-u>call <SID>ToggleFoldcolumn(0)<CR>
nmap     cof coz

function! s:ToggleFoldcolumn(fold) "{{{
  if &foldcolumn
    let w:foldcolumn = &foldcolumn
    silent setlocal foldcolumn=0
    if a:fold | silent setlocal nofoldenable | endif
  else
    if exists('w:foldcolumn') && (w:foldcolumn!=0)
      silent let &l:foldcolumn=w:foldcolumn
    else
      silent setlocal foldcolumn=4
    endif
    if a:fold | silent setlocal foldenable | endif
  endif
  setlocal foldcolumn?
endfunction "}}}
"}}}1

" Colorscheme                                                               {{{1
if (has('termguicolors'))
  " True colors
  set termguicolors
endif

syntax enable
colorscheme gruvbox
set background=dark

" Setting background past textwidth characters
" let &colorcolumn=join(range(81,999),",")
"}}}1
"
" Environments (GUI/Console)                                                {{{1
if has('gui_running')   " GUI Vim                                           {{{

  set guifont=Hack:h13

  " Remove all the UI cruft
  set guioptions-=T                       " Hide the toolbar
  set guioptions-=m                       " Hide the menu
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r
  set guioptions-=R
  set guioptions+=c

  highlight SpellBad term=underline gui=undercurl guisp=Orange

  map <silent> <F11>
        \    :call system("wmctrl -ir " . v:windowid . " -b toggle,fullscreen")<CR>

  " Use First tmux pane on Macvim
  let g:VimuxUseExistingPaneWithIndex = 1

  augroup on_gui_running "{{{
    autocmd!
    " custom event to use it on-demand loading of plugins
    autocmd VimEnter * silent! GuiRunning
  augroup END "}}}

  if has('gui_macvim') "{{{
    " Full screen means FULL screen
    set fuoptions=maxvert,maxhorz
    "}}}
  elseif has('gui_gtk2') "{{{
    " Maximize gvim window.
    set lines=999 columns=999
    "}}}
  else "{{{
    " Non-MacVim GUI
  end "}}}
  "}}}
elseif $TMUX !=# ''      " In tmux session                                   {{{

  " These sequences tell tmux to change the cursor shape to a bar or block.

  " When entering insert mode, change the cursor to a bar.
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  " When exiting insert mode, change it back to a block.
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  "}}}
else                    " Console Vim. For me, this means iTerm2            {{{

  " These sequences tell iterm2 to change the cursor shape to a bar or block.

  " When entering insert mode, change the cursor to a bar.
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  " When exiting insert mode, change it back to a block.
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"

endif "}}}
if has('nvim')          " NeoVim                                            {{{
  " Show cursor bar in insert mode for neovim
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

  " WORKAROUND: Fix C-h navigation between tmux panes. It captures the backspace
  " that neovim receives when Ctrl+h is typed in normal mode
  nnoremap <silent> <BS> :TmuxNavigateLeft<cr>
endif "}}}
"}}}1

" TODO                                                                      {{{1
" * Add more customized snippets
" * Fix annoying bug with YCM that's clears whole word when type
"}}}1
